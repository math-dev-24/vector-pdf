# Cursor Rules - Vector PDF Project

## ğŸ—ï¸ Architecture

### Structure Modulaire
- **`src/core/`** : Ã‰lÃ©ments fondamentaux (config, logging, cache, singletons, retry, metrics)
- **`src/pipeline/`** : Logique mÃ©tier pure (services, models, pipeline)
- **`src/cli/`** : Interface utilisateur (sÃ©parÃ©e de la logique mÃ©tier)
- **`src/extractors/`** : Extraction PDFs
- **`src/processors/`** : Traitement documents
- **`src/vectorization/`** : Vectorisation et stockage

### Principes Architecturaux
- **DRY** : Pas de duplication de code
- **SRP** : Une responsabilitÃ© par classe
- **Architecture Hexagonale** : Ports (interfaces) et Adapters (implÃ©mentations)
- **Injection de DÃ©pendances** : Services injectÃ©s dans le Pipeline

### SÃ©paration des ResponsabilitÃ©s
- **Services mÃ©tier** : Logique pure, sans I/O utilisateur (pas de `print()`, `input()`)
- **Interface CLI** : Interaction utilisateur uniquement
- **Pipeline** : Orchestration des services

## ğŸ“ Conventions de Code

### Configuration
- Utiliser `src.core.settings` pour toute la configuration
- Configuration centralisÃ©e avec Pydantic Settings
- Validation automatique au dÃ©marrage

```python
from src.core import settings
# settings.data_dir, settings.output_dir, etc.
```

### Logging
- Utiliser `get_logger(__name__)` au lieu de `print()`
- Logging structurÃ© avec niveaux appropriÃ©s

```python
from src.core import get_logger
logger = get_logger(__name__)
logger.info("Message")
logger.error("Erreur", exc_info=True)
```

### Gestion d'Erreurs
- Utiliser `PipelineError` avec `ErrorType` pour les erreurs mÃ©tier
- Logger automatiquement les erreurs

```python
from src.core import PipelineError, ErrorType
raise PipelineError(
    ErrorType.EMBEDDING,
    "Message d'erreur",
    original_error=e
)
```

### Clients API
- Utiliser les singletons pour Ã©viter les instanciations multiples

```python
from src.core import OpenAIClient, PineconeClient
client = OpenAIClient().client  # RÃ©utilisÃ© automatiquement
```

### Retry Logic
- Utiliser `retry_with_backoff` pour les appels API

```python
from src.core import retry_with_backoff

@retry_with_backoff(max_attempts=3, initial_delay=2.0)
def api_call():
    pass
```

### Cache
- Cache automatique des embeddings au niveau chunk
- Utiliser `get_embedding_cache()` pour accÃ©der au cache

```python
from src.core.cache import get_embedding_cache
cache = get_embedding_cache()
cached = cache.get(content, model)
cache.set(content, model, embedding)
```

## ğŸ”§ Services MÃ©tier

### CrÃ©ation de Services
- HÃ©riter des interfaces dans `src/pipeline/interfaces.py`
- Logique pure, pas d'I/O utilisateur
- Retourner des objets `Result` (ExtractionResult, ChunkingResult, etc.)

```python
from src.pipeline.interfaces import IExtractionService
from src.pipeline.models import ExtractionResult

class ExtractionService(IExtractionService):
    def extract(...) -> ExtractionResult:
        # Logique pure uniquement
        return ExtractionResult(...)
```

### ModÃ¨les de DonnÃ©es
- Utiliser les dataclasses dans `src/pipeline/models.py`
- Utiliser les Enums pour les choix limitÃ©s

```python
from src.pipeline.models import (
    ExtractionMode,
    PDFFilter,
    ChunkingMode,
    ExtractionResult
)
```

## ğŸ¯ Patterns Importants

### Pipeline Pattern
- Le Pipeline orchestre les services
- Chaque Ã©tape retourne un Result
- Gestion d'erreurs centralisÃ©e

```python
from src.pipeline import Pipeline, PipelineConfig

config = PipelineConfig(...)
pipeline = Pipeline(config=config)
result = pipeline.run_full()
```

### Service Pattern
- Services indÃ©pendants et testables
- Injection de dÃ©pendances
- Interfaces pour faciliter les mocks

### State Manager
- Utiliser `StateManager` pour sauvegarder/charger les Ã©tats intermÃ©diaires
- Cache des chunks et embeddings

```python
from src.processors import StateManager
state_manager = StateManager(str(settings.cache_dir))
state_manager.save_chunks(results)
state_manager.load_chunks()
```

## ğŸ“ Type Hints

### Toujours utiliser des type hints
- ParamÃ¨tres et retours de fonctions
- Variables importantes
- Utiliser `Optional` pour les valeurs optionnelles

```python
from typing import List, Dict, Optional
from pathlib import Path

def process(
    data: List[Dict],
    output_dir: Path,
    verbose: bool = True
) -> Optional[Dict]:
    pass
```

## ğŸš« Ã€ Ã‰viter

### Dans les Services MÃ©tier
- âŒ `print()` - Utiliser `logger`
- âŒ `input()` - Pas d'interaction utilisateur
- âŒ Gestion d'erreurs gÃ©nÃ©rique `except Exception`
- âŒ Instanciation directe de clients API

### Dans le Code GÃ©nÃ©ral
- âŒ Configuration hardcodÃ©e
- âŒ Duplication de code
- âŒ Logique mÃ©tier dans l'interface CLI
- âŒ Pas de type hints

## âœ… Bonnes Pratiques

### Code Propre
- Fonctions courtes et focalisÃ©es
- Noms explicites
- Docstrings pour les fonctions publiques
- Commentaires pour la logique complexe

### Performance
- Utiliser le cache des embeddings
- Batch processing pour les APIs
- Multithreading quand appropriÃ© (configurable)

### Tests
- Utiliser les interfaces pour crÃ©er des mocks
- Tester chaque service indÃ©pendamment
- Tests unitaires pour la logique mÃ©tier

## ğŸ”„ Flux de DonnÃ©es

### Pipeline Complet
```
1. Extraction (ExtractionService)
   PDFs â†’ Markdown

2. Chunking (ChunkingService)
   Markdown â†’ Chunks

3. Embedding (EmbeddingService)
   Chunks â†’ Embeddings (avec cache)

4. Storage (StorageService)
   Embeddings â†’ Pinecone
```

## ğŸ“¦ Imports Standards

### Core
```python
from src.core import (
    settings,
    get_logger,
    PipelineError,
    ErrorType,
    OpenAIClient,
    retry_with_backoff,
    MetricsCollector
)
```

### Pipeline
```python
from src.pipeline import (
    Pipeline,
    PipelineConfig,
    ExtractionService,
    ChunkingService,
    EmbeddingService,
    StorageService
)
from src.pipeline.models import (
    ExtractionMode,
    PDFFilter,
    ChunkingMode
)
```

## ğŸ¨ Structure des Fichiers

### Nouveau Service
1. CrÃ©er l'interface dans `src/pipeline/interfaces.py`
2. ImplÃ©menter dans `src/pipeline/services.py`
3. Ajouter le modÃ¨le Result dans `src/pipeline/models.py`
4. Utiliser dans `Pipeline`

### Nouveau Module Core
1. CrÃ©er dans `src/core/`
2. Exporter dans `src/core/__init__.py`
3. Documenter l'utilisation

## ğŸ” Points Techniques ClÃ©s

### Configuration
- Pydantic Settings avec validation
- Variables d'environnement via `.env`
- Paths automatiquement convertis en `Path`

### Cache
- Hash SHA256 pour identifier les chunks
- Structure de dossiers optimisÃ©e (2 premiers caractÃ¨res)
- Cache dÃ©sactivable via `EMBEDDING_CACHE_ENABLED`

### MÃ©triques
- `MetricsCollector` pour tracker les performances
- Estimation des coÃ»ts API
- Suivi des erreurs

### Retry
- Exponential backoff configurable
- Logging automatique des tentatives
- Exceptions spÃ©cifiques capturables

## ğŸ“š Documentation

- `ARCHITECTURE.md` : Architecture dÃ©taillÃ©e
- `GUIDE_MIGRATION.md` : Guide de migration
- `ANALYSE_AMELIORATIONS.md` : Analyse complÃ¨te
- `AMELIORATIONS_SUPPLEMENTAIRES.md` : AmÃ©liorations rÃ©centes

## ğŸš€ Commandes Utiles

### Lancer le pipeline
```bash
python generate.py
```

### Lancer les requÃªtes
```bash
python ask.py
```

### VÃ©rifier les lints
```bash
# Les lints sont automatiques dans Cursor
```

## ğŸ’¡ Rappels Importants

1. **Toujours utiliser `settings`** au lieu de variables d'environnement directes
2. **Logger au lieu de print** dans le code mÃ©tier
3. **Interfaces pour les services** pour faciliter les tests
4. **Type hints partout** pour la qualitÃ© du code
5. **Services purs** sans I/O utilisateur
6. **Cache automatique** pour les embeddings
7. **Retry logic** pour les APIs
8. **MÃ©triques** pour monitorer les performances
